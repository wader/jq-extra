# jq-extra

Extra builtins for jq.

> [!WARNING]
> This is mostly a proof of concept at the moment.

## Install and update

To install first time or update run `make install`:

```sh
$ make install
Installing ~/.jq symlink
Rebuilding .jq
$ jq -r gron <<< '{"hello": "world"}'
. = {}
.hello = "world"
```

## Own functions

`make install` includes `src/*.jq` so you can put your own functions in `src/local.jq` for example.

## Functions
- [`from_base`](#from_base)
- [`from_base($base)`](#from_base__base_)
- [`from_base($base; $table)`](#from_base__base___table_)
- [`to_base($base)`](#to_base__base_)
- [`to_base($base; prefix)`](#to_base__base__prefix_)
- [`to_base($base; prefix; $table)`](#to_base__base__prefix___table_)
- [`chunks($size)`](#chunks__size_)
- [`chunks($size; s)`](#chunks__size__s_)
- [`count`](#count)
- [`count_by(f)`](#count_by_f_)
- [`from_duration`](#from_duration)
- [`to_duration`](#to_duration)
- [`gron`](#gron)
- [`runs`](#runs)
- [`runs_by(f)`](#runs_by_f_)
- [`runs_by(f; s)`](#runs_by_f__s_)
- [`from_uri`](#from_uri)
- [`to_uri`](#to_uri)
- [`with_uri(f)`](#with_uri_f_)
#### <a name="from_base"></a>`from_base` - Convert string to number and infer base.
- `"0xff" | from_base` → `255`

#### <a name="from_base__base_"></a>`from_base($base)` - Convert string to number in base.
- `"ff" | from_base(16)` → `255`

#### <a name="from_base__base___table_"></a>`from_base($base; $table)` - Convert string to number in base and custom digits table
- `"baab" | from_base(2; {"a": 0, "b": 1})` → `9`

#### <a name="to_base__base_"></a>`to_base($base)` - Convert number to string in base.
- `255 | to_base(16; "")` → `"0xff"`

#### <a name="to_base__base__prefix_"></a>`to_base($base; prefix)` - Convert number to string in base using custom prefix.
- `255 | to_base(16; "")` → `"ff"`

#### <a name="to_base__base__prefix___table_"></a>`to_base($base; prefix; $table)` - Convert number to string in base using custom prefix and digits table.
- `9 | to_base(2; "2#"; "ab")` → `"2#baab"`

#### <a name="chunks__size_"></a>`chunks($size)` - Split array into sized chunks
- `[1,2,3,4,5,6] | chunks(2)` → `[1, 2], [3, 4], [5, 6]`

#### <a name="chunks__size__s_"></a>`chunks($size; s)` - Collect stream s into sized chunks
- `chunks(2; 1,2,3,4,5,6)` → `[1, 2], [3, 4], [5, 6]`

#### <a name="count"></a>`count` - Count unique values in array
- `["a","b","b","b","c","c"] | count` → `[["a",1],["b",3],["c",2]]`

#### <a name="count_by_f_"></a>`count_by(f)` - Count unique values in array based on condition
Similar to `group_by(f)` but counts instead.
- `[101,201,300] | count_by(. % 10)` → `[[0,1],[1,2]]`

#### <a name="from_duration"></a>`from_duration` - From hh:mm::ss.s to seconds
Convert a duration string into seconds.
- `"01:02:03.45" | from_duration` → `3723.45`

#### <a name="to_duration"></a>`to_duration` - From seconds to hh::mm::ss.s
Convert seconds into duration string.
- `3723.45 | to_duration` → `"01:02:03.45"`

#### <a name="gron"></a>`gron` - Output all paths in input as expressions
Similar to https://github.com/tomnomnom/gron.
```sh
$ jq -r gron <<< '{"a":1}'`
. = {}
.a = 1
```
- `{a: [1], b: true} | gron` → `". = {}", ".a = []", ".a[0] = 1", ".b = true"`

#### <a name="runs"></a>`runs` - Group runs of equal values
- `[1, 2, 2, 3] | runs` → `[1], [2, 2], [3]`

#### <a name="runs_by_f_"></a>`runs_by(f)` - Group runs of equal values mapped by f
- `[1, 2, 2.4, 3] | runs_by(floor)` → `[1], [2, 2.4], [3]`

#### <a name="runs_by_f__s_"></a>`runs_by(f; s)` - Group runs of equal values mapped by f from stream s
- `[{a:1,b:1}, {a:2,b:2}, {a:3,b:2}] | runs_by(.[]; .b)` → `[[{"a":1,"b":1}], [{"a":2,"b":2},{"a":3,"b":2}]`

#### <a name="from_uri"></a>`from_uri` - Parse URI from string into an object
Implements `rfc3986`: Uniform Resource Identifier (URI): Generic Syntax
Directly based on [Appendix B.  Parsing a URI Reference with a Regular Expression](https://www.rfc-editor.org/rfc/rfc3986#appendix-B)
- `"scheme://authority/path?key=value#fragment" | from_uri` → `{ "scheme": "scheme", "authority": "authority", "path": "/path", "query": { "key": "value" }, "fragment": "fragment" }`

#### <a name="to_uri"></a>`to_uri` - Reconstructs a URI from the object generated by `from_uri`
Implementation based on [Section 5.3. Component Recomposition](https://www.rfc-editor.org/rfc/rfc3986#section-5.3)
- `{ "scheme": "scheme", "authority": "authority", "path": "/path", "query": { "key": "value" }, "fragment": "fragment" }"scheme://authority/path?key=value#fragment" | to_uri | "scheme://authority/path?key=value#fragment"`

#### <a name="with_uri_f_"></a>`with_uri(f)` - shorthand for `from_uri | f | to_uri`
Useful for mutating from one URI to another
- `"https://example.com/some-random-id?si=tracking-parameter" | with_uri(del(.query.si))` → `"https://example.com/some-random-id"`

## Development

```sh
# run tests
$ make test

# regenerate README.md documentation
$ make README.md
```

## TODO

- Functions:
  - `ungron`
  - `expr_to_path`/`path_to_expr`
  - More array functions
  - json5?
- Include/Exclude config?
- Test with jq, gojq and jaq
  - As all don't support run-tests maybe generate jq code?
- Use public domain license to be copy/paste friendly?

## License

See [LICENSE](LICENSE).
